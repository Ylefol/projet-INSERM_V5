

#Function creations
#############################################################################################################################################

#A function that is called to remove empty plots that are generated by R.
#A common error/bug in R is that when files are automatically saved as pdf's, R opens up an Rplot.pdf to allocate the space for that pdf
#However if we do not use that pdf (which is our case), it remains present, empty, and open. After around 50 open pdf files, R crashes.
#This function was created to delete these files every so often to prevent an accumulation of emtpy Rplots, thus preventing crashes
remove_Rplots <- function (Directory)
{
  Files_to_Remove <- list.files(Directory, recursive = TRUE, all.files = TRUE, pattern="Rplots")
  for (i in Files_to_Remove){
    unlink(paste(Directory,"\\",i,sep=""))
  }
}

#Checks the validity of an entered e-mail
isValidEmail <- function(x) 
{
  grepl("\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\>", as.character(x), 
        ignore.case=TRUE)
}

#Create the function for Deseq2
#This function takes in two files representing two condition (which are also entered as parameters)
#it will then perform a differential analysis on these gene files and produce various results
#A differential expression file will be created (containing all genes), a significant gene differential expression file will also be created
#Along with a simple list of significant genes in a third file.
#Additionnaly, depending on the value of the do_MA_plot and do_Volcano_Plot parameters (TRUE or FALSE)
#The function will create and save two of each type of figure, one with text and the other without. (4 figures total)
DESeq2_pre_processing <- function(File_1, File_2, variable_condition_1, variable_condition_2, do_MA_plot, do_Volcano_Plot)
{
  
  #Everything is in a try catch to ensure that the application does not crash in the event of an error
  #If an error does occur, it was desired that the application prints the error in a txt file and tells the user that an error has occured
  tryCatch({
    
    ###################################################################################################################################
    #File preperations for a file merge, i.e obtaining the necessary format for DESeq2 preprocessing
    ###################################################################################################################################
    File_1 <- read.csv(file = File_1,check.names=FALSE)
    File_2 <-read.csv(file = File_2,check.names=FALSE)
    
    #Filters out 0's and NA's, if a file is properly prepared, none of these should occur
    File_1<-File_1[complete.cases(File_1),]
    File_1<-File_1[!(File_1$Gene=="0.0"),]
    
    File_2<-File_2[complete.cases(File_2),]
    File_2<-File_2[!(File_2$Gene=="0.0"),]
    
    
    
    #Counts the number of collumns/patients in each file
    num_1 <- ncol(File_1)-1
    num_2 <- ncol(File_2)-1
    
    
    #Remove first column of Quartile that is being added
    #These are the counts that are will be merged to another
    new_file_1<- File_1[,-1]
    new_file_2<- File_2[,-1]
    
    
    #Create 'merged' Quartiles
    merged_files <- cbind(File_1,new_file_2)
    rownames(merged_files)=merged_files[,1]
    merged_files <- merged_files[,-1]
    
    #converts it to numeric
    merged_files <- data.frame(sapply(merged_files, as.numeric),check.names=F, row.names = rownames(merged_files))
    
    #Creates the matrices
    merged_files <- as.matrix(merged_files)
    
    #Assign Condition Q1 to all of the columns/samples/patients
    condition <- factor(c(rep(variable_condition_1, num_1),rep(variable_condition_2,num_2)))
    ####################################################################################
    #Create a coldata frame and instantiate the DESeqDataSet
    (col_data <- data.frame(row.names=colnames(merged_files),condition))
    dds <- DESeqDataSetFromMatrix(countData=merged_files, colData=col_data, design=~condition)
    ###################################################################################################################################
    
    dds = estimateSizeFactors(dds)
    
    #Run the DESeq pipeline, this takes a while
    dds <- DESeq(dds)
    
    ###################################################################################################################################
    #Change the format into something that can be used by R (dds --> res)
    ###################################################################################################################################
    res <- results(dds)
    
    #Could be used if they want to reduce?
    #res <- lfcShrink(dds, coef=2, type="apeglm")
    
    #Orders the results via adjusted p-value
    res <- res[order(res$padj), ]
    # Merge with normalized count data
    resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
    names(resdata)[1] <- "Genes"
    head(resdata)
    pre_processed_file_full<-resdata
    ## Write results
    write.csv(resdata, file=paste("diffexpr_results",variable_condition_1,"vs",variable_condition_2,".csv",sep=""),row.names=FALSE,quote = FALSE)
    
    ## MA plots
    ###################################################################################################################################
    #Sets up the function
    maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
        with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
        }
      },error=function(error_message){
      })
    }
    
    #Calls the function if the condition is met
    if (do_MA_plot==TRUE){
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png",sep=""), 7500, 7000, pointsize=15)
      suppressWarnings(maplot(resdata, main="MA Plot"))
      invisible(dev.off())
      #With text
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png",sep=""), 2500, 2000, pointsize=15)
      suppressWarnings(maplot(resdata, main="MA Plot",labelsig = FALSE))
      invisible(dev.off())
    }
    
    
    ## Volcano plot with "significant" genes in green with text
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_text <- function (res, lfcthresh=1, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
        }
        legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","green"))
      },error=function(error_message){
      })
    }
    
    #Calls the function
    if(do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png",sep=""), 5200, 5000, pointsize=20)
      suppressWarnings(volcanoplot_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }
    
    
    ## Volcano plot with "significant" genes in green with no text active_reformed
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_no_text <- function (res, lfcthresh=2, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        x <-subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh)
        write.csv(x,file = paste(variable_condition_1,"vs",variable_condition_2,"_RESULTS_VOLCANO.csv",sep=""),row.names=FALSE,quote = FALSE)
        return (x)
      },error=function(error_message){
      })
    }
    
    #Calls the function
    #this one is special, the function will be called regardless as it is used to produce the necessary list (X) which gives significant genes
    #However, depending on what the user wants, the function will only produce a list, or it will produce a list and create the corresponding volcano plot
    if (do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png",sep=""), 1200, 1000, pointsize=20)
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }else{
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
    }
    
    ###################################################################################################################################
    #Creates a list of significant genes according to the volcano plot
    file_for_sig_genes <-  pre_processed_file_short['Genes']
    
    write.csv(file_for_sig_genes,file=paste("gene_list_",variable_condition_1,"vs",variable_condition_2,"_Most_Significant.txt",sep=""),row.names=FALSE,col.names = TRUE,quote = FALSE)
    ###################################################################################################################################
    
    pre_processed_file_short <- pre_processed_file_short[,1:7]
    # rownames(pre_processed_file_short) <- pre_processed_file_short[,1]
    # pre_processed_file_short <- pre_processed_file_short[,-1]
    
    #Reached the end of the function without errors
    return_message<-paste("success, your file is located here:",getwd())
  },
  error=function(error_message){
    outputFile <- "Error_and_Warning_Log.txt"
    writeLines(as.character(error_message), outputFile)
    return_message <- paste("Error, please check the 'Error_and_Warning_Log.txt' located here:",getwd())
  }
  )
  
  return_list <- list("message"=return_message,"file"=pre_processed_file_short)
  return (return_list)
}

#Connects to the database once the user has filled in the form
#Before starting the connection, this function kills any existing connections to the database.
Connect_to_database <- function(email="error_occured", type_research="error_occured", comments="error_occured",date=Sys.Date(),second_try)
{
  killDbConnections()
  
  #Starts a for loop that will try a connection once if the 'second_try' variable is FALSE
  #However if the second_try variable is TRUE, it will continue in the loop (if the initial connection does not work)
  #It will then try to connect three times on a 30 second interval, if on the last try the connection does not work, a "END" return message is sent.
  #This will be used to interpret a failure in the database connection
  for (i in 1:3){
    tryCatch({
      invisible(DB <- dbConnect(RMySQL::MySQL(), user="cellomet_user", host="sqlgold.webmo.fr",password="Charly_Mike", dbname="cellomet1",port=50413))
      #Will not run this query if there is an error in the connection
      dbGetQuery(DB, paste0("INSERT INTO `questionnaire` (`Email`, `Type_of_Study`, `Comments`, `submit_date`) VALUES ('",email,"', '",type_research,"', '",comments,"', '",Sys.Date(),"');"))
      break
    },error=function(error_message){
      print(error_message)
    })
    if(second_try==TRUE){
      Sys.sleep(30)
      if (i==3){
        DB=NULL
      }
    }else{
      message_DB <- "END"
      return(message_DB)
    }
    
  }
  #dbGetQuery(DB, paste0("INSERT INTO `questionnaire`(`Email`, `Type_of_Study`, `Comments`,`submit_date`) VALUES (\"",email,"\",\"",type_research,"\",\"",comments,"\",\"",Sys.Date(),"\");"))
  killDbConnections()
  return(DB)
}

#Removes all connections
killDbConnections <- function () 
{
  all_cons <- dbListConnections(MySQL())
  for(con in all_cons)
    +  dbDisconnect(con)
}

#Uses the database connection to check for non_canonical genes
#This function takes in a file which will contain at least one column with the name 'Genes', this column will then be read
#and filtered to find (if any) non-canonical genes according to the database
#The function then writes three result files if any results were found, it then returns what it has found in the form of a list
Non_canonic_analysis <- function(DB,file_to_analyze,hsa_choice=FALSE)
{
  #If the user has chosen to perform the hsa conversion
  if(hsa_choice==TRUE){
    convert_gene_to_hsa(file_to_analyze)
  }
  #Recharge the connection
  for (i in 1:3){
    tryCatch({
      invisible(DB <- dbConnect(RMySQL::MySQL(), user="cellomet_user", host="sqlgold.webmo.fr",password="Charly_Mike", dbname="cellomet1",port=50413))
      break
    },error=function(error_message){
      
    })
    Sys.sleep(30)
    if (i==3){
      DB=NULL
      return_message_ncan<-"END"
      return(return_message_ncan)
    }
  }

  sig_gene_list<-file_to_analyze$Genes
  
  #Initialize dataframes
  non_canonic_results <- data.frame(
    Gene_Symbol=character(),
    NC_Pathway=character(), 
    NC_Loc=character(), 
    num_ncan=integer(),
    stringsAsFactors=FALSE)
  
  canonic_results <- data.frame(
    Gene_Symbol=character(),
    Gene_Name = character(),
    NC_Pathway=character(), 
    NC_Loc=character(), 
    num_ncan=integer(),
    stringsAsFactors=FALSE) 
  
  ref_results <- data.frame(
    Gene_Symbol=character(),
    ref = character(),
    stringsAsFactors=FALSE) 
  
  
  for (i in 1:length(sig_gene_list)){
    if (nrow(dbGetQuery(DB, paste0("SELECT * FROM canonic WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))>0){
      non_canonic_results <- rbind(non_canonic_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, C_category as Category, NC_Pathway as Non_Canonic_Pathway, NC_Loc as Non_Canonic_Location FROM ncanonic join canonic using (Gene_Symbol) WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
      canonic_results <- rbind(canonic_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, C_category as Category, C_Pathway as Canonical_Pathway, C_Loc as Canonical_Location FROM canonic WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
      ref_results <- rbind(ref_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, ref as `References` FROM `refs` join canonic using (Gene_Symbol) WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
    }
    
  }
  
  #Kill the connection after every use
  killDbConnections()

  #Store each dataframe in a list for return
  
  my_results_list <- list("sig_genes"=file_to_analyze,"ncan"=non_canonic_results,"can"=canonic_results,"refs"=ref_results)
  
  if(nrow(my_results_list[["ncan"]])>0){
    write.table(my_results_list[["ncan"]],file = "non_canonic_results.txt",row.names = FALSE,quote = FALSE,sep = "\t")
    
    write.table(my_results_list[["can"]],file = "canonic_results.txt",row.names = FALSE,quote = FALSE,sep = "\t")
    
    write.table(my_results_list[["refs"]],file = "references.txt",row.names = FALSE,quote = FALSE,sep = "\t")
  }
  
  return(my_results_list)
}

#A function to create an MA plot, this one contains many parameters as to allow users to customize the MA plot to their convenience
custom_MA_plot <- function (fig_file, sig_pval=0.05, labelsig=FALSE, textcx=1,use_alternate_color=FALSE, ...) 
{
  file_to_plot <-read.csv(file = fig_file,check.names=FALSE)
  
  if(use_alternate_color==TRUE){
    main_color="blue"
    sig_color="green"
  }else{
    main_color="black"
    sig_color="red"
  }
  
  with(file_to_plot, plot(baseMean, log2FoldChange, col=main_color, pch=20, cex=.5, log="x", ...))
  with(subset(file_to_plot, padj<sig_pval), points(baseMean, log2FoldChange, col=sig_color, pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(file_to_plot, padj<sig_pval), textxy(baseMean, log2FoldChange, labs=Genes, cex=textcx, col=2))
  }
  
}

#A function to create a Volcano plot, this one contains many parameters as to allow users to customize the MA plot to their convenience
custom_Volcano_plot <- function (fig_file, lfcthresh=1, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=FALSE, textcx=1, use_alternate_colors=FALSE, ...) 
{
  
  file_to_plot <-read.csv(file = fig_file,check.names=FALSE)
  
  if (use_alternate_colors==TRUE){
    main_color="blue"
    sig_both_color="green"
    sig_padj_color="magenta"
    sig_lfc_color="orange"
  }else{
    main_color="black"
    sig_both_color="green"
    sig_padj_color="red"
    sig_lfc_color="orange"
  }
  
  
  with(file_to_plot, plot(log2FoldChange, -log10(pvalue), pch=20, main=main,col=main_color, ...))
  with(subset(file_to_plot, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col=sig_padj_color, ...))
  with(subset(file_to_plot, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col=sig_lfc_color, ...))
  with(subset(file_to_plot, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col=sig_both_color, ...))
  if (labelsig) {
    require(calibrate)
    with(subset(file_to_plot, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Genes, cex=textcx, ...))
  }
  legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c(sig_padj_color,sig_lfc_color,sig_both_color))
  
}

#A function that will enable or disable all elements of the custom_MA_tab depending on the boolean value of the parameter
#This function is to lock the tab (and other tabs) once it is 'working', ensuring that the user cannot crash the application by qeuing up too many actions
enable_disable_MA_plot <- function(enable_MA)
{
  if(enable_MA==TRUE){
    enable("create_MA")
    enable("download_MA_plot")
    enable("download_MA_data")
    enable("file_custom_MA")
    enable("text_choice_MA")
    enable("alternate_color_scheme_MA")
    enable("p_value_thresh_MA")
    enable("title_of_MA_plot")
    enable_disable_tabs(TRUE)
  }else{
    disable("create_MA")
    disable("download_MA_plot")
    disable("download_MA_data")
    disable("file_custom_MA")
    disable("text_choice_MA")
    disable("alternate_color_scheme_MA")
    disable("p_value_thresh_MA")
    disable("title_of_MA_plot")
    enable_disable_tabs(FALSE)
  }
}

#Same function as above except for the custom_volcano_plot tab
enable_disable_volcano_plot <- function(enable_Volcano)
{
  if(enable_Volcano==TRUE){
    enable("create_Volcano")
    enable("download_Volcano_plot")
    enable("download_Volcano_data")
    enable("file_custom_Volcano")
    enable("text_choice_Volcano")
    enable("alternate_color_scheme_Volcano")
    enable("p_value_thresh_Volcano")
    enable("title_of_Volcano_plot")
    enable("lfc_value_thresh")
    enable("legend_position")
    enable_disable_tabs(TRUE)
  }else{
    disable("create_Volcano")
    disable("download_Volcano_plot")
    disable("download_Volcano_data")
    disable("file_custom_Volcano")
    disable("text_choice_Volcano")
    disable("alternate_color_scheme_Volcano")
    disable("p_value_thresh_Volcano")
    disable("title_of_Volcano_plot")
    disable("lfc_value_thresh")
    disable("legend_position")
    enable_disable_tabs(FALSE)
    
  }
}

#Similar to the two above function, this one locks the side bar selection depending on the value of the parameter
#It is used to ensure that users cannot qeue up actions while the application is already working.
enable_disable_tabs <- function(enable_sidebar)
{
  if (enable_sidebar==TRUE){
    removeCssClass(selector = "a[data-value='info']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='connect_DB']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='DESeq2_analysis']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='gene_list_analysis']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='res']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='cus_MA']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='cus_Volcano']", class = "inactiveLink")
    removeCssClass(selector = "a[data-value='citation']", class = "inactiveLink")
    enable("close")
  }else{
    addCssClass(selector = "a[data-value='info']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='connect_DB']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='DESeq2_analysis']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='gene_list_analysis']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='res']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='cus_MA']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='cus_Volcano']", class = "inactiveLink")
    addCssClass(selector = "a[data-value='citation']", class = "inactiveLink")
    disable("close")
    
  }
}

#This function is run before the non-canonical analysis to ensure that the file submitted contains a 'Genes' column
#If the file does not contain a 'Genes' column, the analysis will not be performed and the user will be asked to upload a proper file.
check_for_genes_column <- function(file_to_check)
{
  found_genes_column=FALSE
  for(i in 1:length(colnames(file_to_check))){
    if(colnames(file_to_check)[i]=="Genes"){
      found_genes_column=TRUE
      break
    }
  }
  return(found_genes_column)
}

#A simple function which calls an already existing function
#this si the only way to call the read.csv function in an observe event
read_csv_function <- function(datapath)
{
  new_file <- read.csv(file = datapath,check.names=FALSE)
  rownames(new_file) = new_file [,1]
  return (new_file)
}

#A function that converts gene_symbols to hsa symbols destined to be used with the KEGGS MAPPER tool
convert_gene_to_hsa<-function(full_file)
{
  options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
  #Read the data inputed by the user
  data <- full_file
  #Put the data in a new variable
  newdata <- data.frame(data[,"Genes"])
  newdata <- data.frame(newdata)
  colnames(newdata)="Genes"
  #Instantiate three empty vectors
  entrez = c()
  Genes=c()
  missing=c()
  
  #Start a for loop that will iterate through each gene in the inputed file
  for (g in 1:length(newdata[[1]])) {
    #'open' the website that corresponds to the gene of the current iteration
    query = paste("http://rest.kegg.jp/find/hsa/",newdata$Genes[g],sep="")
    #Store the query result in a variable
    result = getURL(query)
    #If the website does not exists, i.e gene symbol not found
    if (result=="\n"){
      #Gene symbol not found, therefore the gene is sorted as 'missing'
      missing<-c(missing,as.character(newdata$Genes[g]))
      #Go straight to the next iteration, saves time and prevents bugs
      next()
    }
    #The query returned a webpage containing one or more lines, each line is stored in list and split via \n (one line per list slot)
    my_list <- strsplit(result,"\n")
    
    #Initiate a counter before each iteration of a query result
    found_this_many = 0
    #For loop checks each element of the list (each line of the website) and checks which line contains the desired gene symbol
    for (i in 1:length(my_list[[1]])){
      #Takes the found line and stores it as a vector
      x <- str_replace(my_list[[1]][i],"\t"," ")
      #4 regular expressions that will cover all possibilities of finding a match
      check_comma_tab <- as.character(str_match (x,as.character(paste("\t",newdata$Genes[g],",",sep=""))))
      check_comma_space <- as.character(str_match (x,as.character(paste(" ",newdata$Genes[g],",",sep=""))))
      check_semicolon_tab <- as.character(str_match (x,as.character(paste("\t",newdata$Genes[g],";",sep=""))))
      check_semicolon_space <- as.character(str_match (x,as.character(paste(" ",newdata$Genes[g],";",sep=""))))
      
      #At least one of the regexes found a match
      if (is.na(check_comma_tab)==FALSE | is.na(check_comma_space)==FALSE | is.na(check_semicolon_tab)==FALSE | is.na(check_semicolon_space)==FALSE){
        #Update the counter as a match was found
        found_this_many = found_this_many + 1
        #This ensures that only one match is added in, preventing duplicates
        if (found_this_many == 1){
          Genes<-c(Genes,as.character(newdata$Genes[g]))
          entrez = c(entrez, strsplit(x," ")[[1]][1])
        }
        #If no regex matched, the loop is on the last iteration AND no genes were previously found, it means there is no hsa equivalent
      }else if(i==length(my_list[[1]])&found_this_many==0){
        #No hsa found, thus stored as missing
        missing<-c(missing,as.character(newdata$Genes[g]))
      }
    }
  }
  
  # Squash the found genes list and the hsa equivalent
  with_hsa <- cbind(Genes, entrez)
  
  #Create a list with only the hsa list
  found <- rbind(with_hsa[grep("hsa:", with_hsa[,"entrez"]), ])
  #Writes the hsa table
  write.table(found[,"entrez"], file = "hsa_ID.txt", row.names=FALSE, col.names=FALSE,sep=",",quote = FALSE)
  
  #Write the found and missing table
  write.table(found, file = "convert.txt", row.names=FALSE, col.names=TRUE,sep=",",quote=FALSE)
  write.table(missing, file = "missing.txt", row.names=FALSE, col.names=FALSE,sep=",",quote=FALSE)
  
}

#############################################################################################################################################
